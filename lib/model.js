// Generated by CoffeeScript 1.9.3
(function() {
  var Application, Domain, Model, Q, Sequelize, User, config, db, expandHomeDir, fs, logger, md5, storagePath, validator;

  Sequelize = require('sequelize');

  expandHomeDir = require('expand-home-dir');

  Q = require('q');

  fs = require('fs-extra');

  logger = require('./logger');

  config = require('./config');

  md5 = require('md5');

  validator = require('validator');

  storagePath = expandHomeDir(config.DATABASE_PATH);

  logger.debug('db path', storagePath);

  db = new Sequelize('sqlite://', {
    logging: logger.debug,
    storage: storagePath
  });

  Application = db.define('Application', {
    name: {
      type: Sequelize.STRING,
      unique: true
    },
    config: {
      type: Sequelize.TEXT('medium'),
      get: (function() {
        return JSON.parse(this.getDataValue('config')) || {};
      }),
      set: (function(value) {
        return this.setDataValue('config', JSON.stringify(value));
      })
    }
  });

  Domain = db.define('Domain', {
    name: {
      type: Sequelize.STRING,
      unique: true
    }
  });

  User = db.define('User', {
    username: {
      type: Sequelize.STRING,
      unique: true
    },
    password: Sequelize.STRING
  });

  Application.hasMany(Domain, {
    onDelete: 'cascade'
  });

  Domain.belongsTo(Application);

  User.belongsToMany(Application, {
    through: 'UserApplications'
  });

  Application.belongsToMany(User, {
    through: 'UserApplications'
  });

  Model = (function() {
    function Model() {}

    Model.prototype.ensureStorage = function() {
      return Q.fcall((function(_this) {
        return function() {
          var deferred;
          deferred = Q.defer();
          fs.exists(storagePath, function(exists) {
            if (exists) {
              return deferred.resolve();
            } else {
              return db.sync().then(deferred.resolve)["catch"](deferred.reject);
            }
          });
          return deferred.promise;
        };
      })(this));
    };

    Model.prototype.sync = function(options, callback) {
      return db.sync(options).then(callback)["catch"](callback);
    };

    Model.prototype.createApplication = function(data, callback) {
      return this.ensureStorage().then(function() {
        return Application.create(data);
      }).then(function(app) {
        return callback(null, app);
      })["catch"](callback);
    };

    Model.prototype.deleteApplication = function(appNameOrID, callback) {
      var application;
      application = null;
      return this.ensureStorage().then(function() {
        var orStatement;
        orStatement = [];
        if (typeof appNameOrID === 'string') {
          orStatement.push({
            name: appNameOrID
          });
        }
        if (validator.isInt(appNameOrID)) {
          orStatement.push({
            id: appNameOrID
          });
        }
        return Application.findOne({
          where: {
            $or: orStatement
          }
        }).then(function(app) {
          application = app;
          if (!app) {
            throw new Error('application ' + appNameOrID + ' not found');
          }
          return app.destroy();
        });
      }).then(function() {
        return callback(null, application);
      })["catch"](callback);
    };

    Model.prototype.getApplications = function(callback) {
      return this.ensureStorage().then(function() {
        return Application.findAll().then((function(_this) {
          return function(apps) {
            return callback(null, apps);
          };
        })(this))["catch"](callback);
      });
    };

    Model.prototype.getApplication = function(appNameOrID, callback) {
      return this.ensureStorage().then(function() {
        var orStatement;
        orStatement = [];
        if (typeof appNameOrID === 'string') {
          orStatement.push({
            name: appNameOrID
          });
        }
        if (validator.isInt(appNameOrID)) {
          orStatement.push({
            id: appNameOrID
          });
        }
        return Application.findOne({
          where: {
            $or: orStatement
          }
        }).then((function(_this) {
          return function(app) {
            if (!app) {
              return callback(new Error('app ' + appNameOrID + ' not found'));
            }
            return callback(null, app);
          };
        })(this))["catch"](callback);
      });
    };

    Model.prototype.portForApplication = function(appNameOrID, callback) {
      return this.getApplication(appNameOrID, function(err, application) {
        if (err) {
          return callback(err);
        }
        return callback(null, config.PORT_START_NUMBER + application.id + 5);
      });
    };

    Model.prototype.getApplicationForHostname = function(hostname, callback) {
      return Domain.findOne({
        where: {
          name: hostname
        }
      }).then(function(domain) {
        if (!domain) {
          return callback(new Error('no application found'));
        }
        return domain.getApplication().then(function(app) {
          return callback(null, app);
        })["catch"](callback);
      })["catch"](callback);
    };

    Model.prototype.addDomainToApplication = function(appNameOrID, domain, callback) {
      return this.getApplication(appNameOrID, function(err, application) {
        var dom;
        if (err) {
          return callback(err);
        }
        return dom = Domain.create({
          name: domain
        }).then(function(dom) {
          return dom.setApplication(application).then(function(domain) {
            return callback(null, domain);
          })["catch"](callback);
        })["catch"](callback);
      });
    };

    Model.prototype.removeDomainFromApplication = function(appNameOrID, domainOrId, callback) {
      return this.getApplication(appNameOrID, function(err, application) {
        var orStatement;
        if (err) {
          return callback(err);
        }
        orStatement = [];
        if (typeof domainOrId === 'string') {
          orStatement.push({
            name: domainOrId
          });
        }
        if (validator.isInt(domainOrId)) {
          orStatement.push({
            id: domainOrId
          });
        }
        return application.getDomains({
          where: {
            $or: orStatement
          }
        }).then(function(domains) {
          var domain;
          if (domains.length === 0) {
            return callback(new Error('domain ' + domainOrId + ' not found'));
          }
          domain = domains[0];
          return domain.destroy().then(function() {
            return callback();
          })["catch"](callback);
        })["catch"](callback);
      });
    };

    Model.prototype.getUsers = function(callback) {
      return User.findAll().then(function(users) {
        return callback(null, users);
      })["catch"](callback);
    };

    Model.prototype.addUser = function(username, password, callback) {
      return User.create({
        username: username,
        password: md5(password)
      }).then(function(user) {
        return callback(null, user);
      })["catch"](callback);
    };

    Model.prototype.removeUser = function(username, callback) {
      return User.findOne({
        where: {
          username: username
        }
      }).then(function(user) {
        if (!user) {
          return callback(new Error('user ' + username + ' not found'));
        }
        return user.destroy().then(function() {
          return callback(null, user);
        })["catch"](callback);
      })["catch"](callback);
    };

    Model.prototype.authorizeUser = function(username, password, callback) {
      return User.findOne({
        where: {
          username: username
        }
      }).then(function(user) {
        if (!user) {
          return callback(null, false);
        }
        return callback(null, user.password === md5(password));
      })["catch"](callback);
    };

    return Model;

  })();

  module.exports = new Model();

}).call(this);
